/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GhostTagPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/editor/ghostExtension.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var defaultConfig = { startDelimiter: "%%", endDelimiter: "%%" };
var ghostConfigFacet = import_state.Facet.define({
  combine(inputs) {
    return inputs.length > 0 ? inputs[inputs.length - 1] : defaultConfig;
  }
});
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function buildGhostRegex(config) {
  const start = escapeRegex(config.startDelimiter);
  const end = escapeRegex(config.endDelimiter);
  return new RegExp(`${start}([\\s\\S]*?)${end}`, "g");
}
function buildDecorations(view) {
  const builder = new import_state.RangeSetBuilder();
  const doc = view.state.doc;
  const config = view.state.facet(ghostConfigFacet);
  const delimStartLen = config.startDelimiter.length;
  const delimEndLen = config.endDelimiter.length;
  const regex = buildGhostRegex(config);
  const cursors = view.state.selection.ranges.map(
    (r) => ({ from: r.from, to: r.to })
  );
  for (const { from, to } of view.visibleRanges) {
    const text = doc.sliceString(from, to);
    regex.lastIndex = 0;
    let m;
    while ((m = regex.exec(text)) !== null) {
      const matchStart = from + m.index;
      const matchEnd = from + m.index + m[0].length;
      const contentStart = matchStart + delimStartLen;
      const contentEnd = matchEnd - delimEndLen;
      if (contentStart >= contentEnd)
        continue;
      const cursorInside = cursors.some(
        (c) => c.from >= matchStart && c.from <= matchEnd
      );
      if (cursorInside) {
        builder.add(matchStart, contentStart, import_view.Decoration.mark({ class: "gt-delim-edit" }));
        builder.add(contentStart, contentEnd, import_view.Decoration.mark({ class: "gt-content-edit" }));
        builder.add(contentEnd, matchEnd, import_view.Decoration.mark({ class: "gt-delim-edit" }));
      } else {
        builder.add(matchStart, matchEnd, import_view.Decoration.mark({ class: "gt-wrapper" }));
        builder.add(matchStart, contentStart, import_view.Decoration.mark({ class: "gt-delim" }));
        builder.add(contentStart, contentEnd, import_view.Decoration.mark({ class: "gt-content" }));
        builder.add(contentEnd, matchEnd, import_view.Decoration.mark({ class: "gt-delim" }));
      }
    }
  }
  return builder.finish();
}
var ghostTagPlugin = import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.decorations = buildDecorations(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.selectionSet || // Rebuild when facet config changes (delimiter changed)
      update.state.facet(ghostConfigFacet) !== update.startState.facet(ghostConfigFacet)) {
        this.decorations = buildDecorations(update.view);
      }
    }
  },
  {
    decorations: (v) => v.decorations,
    provide: () => []
    // No additional provides; keeps priority neutral
  }
);

// src/editor/copyHandler.ts
var import_view2 = require("@codemirror/view");
var import_state2 = require("@codemirror/state");
var defaultCopyConfig = {
  autoStrip: true,
  startDelimiter: "%%",
  endDelimiter: "%%"
};
var ghostCopyConfigFacet = import_state2.Facet.define({
  combine(inputs) {
    return inputs.length > 0 ? inputs[inputs.length - 1] : defaultCopyConfig;
  }
});
function escapeRegex2(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function stripGhostTags(text, start, end) {
  const regex = new RegExp(
    `${escapeRegex2(start)}[\\s\\S]*?${escapeRegex2(end)}`,
    "g"
  );
  return text.replace(regex, "");
}
var ghostCopyHandler = import_view2.EditorView.domEventHandlers({
  copy(event, view) {
    var _a;
    const config = view.state.facet(ghostCopyConfigFacet);
    if (!config.autoStrip)
      return false;
    const selection = view.state.sliceDoc(
      view.state.selection.main.from,
      view.state.selection.main.to
    );
    if (selection.length === 0)
      return false;
    const regex = new RegExp(
      `${escapeRegex2(config.startDelimiter)}[\\s\\S]*?${escapeRegex2(config.endDelimiter)}`
    );
    if (!regex.test(selection))
      return false;
    const stripped = stripGhostTags(
      selection,
      config.startDelimiter,
      config.endDelimiter
    );
    (_a = event.clipboardData) == null ? void 0 : _a.setData("text/plain", stripped);
    event.preventDefault();
    return true;
  }
});

// src/settings/settingTab.ts
var import_obsidian = require("obsidian");

// src/i18n.ts
var ja = {
  settingsTitle: "GhostTag \u8A2D\u5B9A",
  sectionDelimiter: "\u30C7\u30EA\u30DF\u30BF\uFF08\u56F2\u307F\u8A18\u53F7\uFF09",
  startDelimiterName: "\u958B\u59CB\u8A18\u53F7",
  startDelimiterDesc: "GhostTag\u306E\u958B\u59CB\u3092\u793A\u3059\u8A18\u53F7\uFF08\u4F8B: %%, ((, ==\uFF09",
  endDelimiterName: "\u7D42\u4E86\u8A18\u53F7",
  endDelimiterDesc: "GhostTag\u306E\u7D42\u4E86\u3092\u793A\u3059\u8A18\u53F7\uFF08\u4F8B: %%, )), ==\uFF09",
  sectionDisplay: "\u8868\u793A",
  hoverOpacityName: "\u30DB\u30D0\u30FC\u6642\u306E\u4E0D\u900F\u660E\u5EA6",
  hoverOpacityDesc: "\u30DE\u30A6\u30B9\u3092\u4E57\u305B\u305F\u3068\u304D\u306E\u30C6\u30AD\u30B9\u30C8\u306E\u6FC3\u3055 (0\u301C100%)",
  editOpacityName: "\u7DE8\u96C6\u30E2\u30FC\u30C9\u306E\u4E0D\u900F\u660E\u5EA6",
  editOpacityDesc: "\u30AB\u30FC\u30BD\u30EB\u3092\u7F6E\u3044\u305F\u3068\u304D\u306E\u30C6\u30AD\u30B9\u30C8\u306E\u6FC3\u3055 (0\u301C100%)",
  delimOpacityName: "\u30C7\u30EA\u30DF\u30BF\u306E\u4E0D\u900F\u660E\u5EA6",
  delimOpacityDesc: "\u7DE8\u96C6\u30E2\u30FC\u30C9\u3067\u306E\u30C7\u30EA\u30DF\u30BF\u8A18\u53F7\u306E\u6FC3\u3055 (0\u301C100%)",
  animSpeedName: "\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u901F\u5EA6",
  animSpeedDesc: "\u30D5\u30A7\u30FC\u30C9\u30A4\u30F3/\u30A2\u30A6\u30C8\u306E\u6642\u9593 (\u30DF\u30EA\u79D2)",
  sectionCopy: "\u30B3\u30D4\u30FC\u52D5\u4F5C",
  autoStripName: "\u30B3\u30D4\u30FC\u6642\u306BGhostTag\u3092\u81EA\u52D5\u9664\u53BB",
  autoStripDesc: "ON\u306E\u5834\u5408\u3001Ctrl+C\u3067\u30B3\u30D4\u30FC\u3059\u308B\u3068\u304D\u81EA\u52D5\u7684\u306BGhostTag\u304C\u9664\u53BB\u3055\u308C\u307E\u3059",
  copyWithTags: "\u{1F47B} GhostTag\u3092\u542B\u3081\u3066\u30B3\u30D4\u30FC",
  copyWithoutTags: "\u{1F47B} GhostTag\u3092\u9664\u5916\u3057\u3066\u30B3\u30D4\u30FC",
  ghostifySelection: "\u{1F47B} \u9078\u629E\u7BC4\u56F2\u3092Ghost\u5316",
  openScanner: "Ghost Scanner\u3092\u958B\u304F",
  scannerTitle: "\u{1F47B} Ghost Scanner",
  scannerEmpty: "\u3053\u306E\u30CE\u30FC\u30C8\u306BGhostTag\u306F\u3042\u308A\u307E\u305B\u3093",
  scannerNoNote: "\u30DE\u30FC\u30AF\u30C0\u30A6\u30F3\u30CE\u30FC\u30C8\u3092\u958B\u3044\u3066\u304F\u3060\u3055\u3044",
  scannerCount: (n) => `${n} \u4EF6`
};
var en = {
  settingsTitle: "GhostTag Settings",
  sectionDelimiter: "Delimiters",
  startDelimiterName: "Start delimiter",
  startDelimiterDesc: "Symbol that opens a GhostTag (e.g. %%, ((, ==)",
  endDelimiterName: "End delimiter",
  endDelimiterDesc: "Symbol that closes a GhostTag (e.g. %%, )), ==)",
  sectionDisplay: "Display",
  hoverOpacityName: "Hover opacity",
  hoverOpacityDesc: "Text opacity when the mouse hovers over a tag (0\u2013100%)",
  editOpacityName: "Edit mode opacity",
  editOpacityDesc: "Text opacity when the cursor is inside a tag (0\u2013100%)",
  delimOpacityName: "Delimiter opacity",
  delimOpacityDesc: "Delimiter symbol opacity in edit mode (0\u2013100%)",
  animSpeedName: "Animation speed",
  animSpeedDesc: "Fade-in / fade-out duration (milliseconds)",
  sectionCopy: "Copy behavior",
  autoStripName: "Auto-strip GhostTags on copy",
  autoStripDesc: "When ON, Ctrl+C automatically removes GhostTags from copied text",
  copyWithTags: "\u{1F47B} Copy with GhostTags",
  copyWithoutTags: "\u{1F47B} Copy without GhostTags",
  ghostifySelection: "\u{1F47B} Ghostify Selection",
  openScanner: "Open Ghost Scanner",
  scannerTitle: "\u{1F47B} Ghost Scanner",
  scannerEmpty: "No GhostTags in this note",
  scannerNoNote: "Open a markdown note first",
  scannerCount: (n) => `${n} found`
};
var zh = {
  settingsTitle: "GhostTag \u8BBE\u7F6E",
  sectionDelimiter: "\u5B9A\u754C\u7B26\uFF08\u5305\u56F4\u7B26\u53F7\uFF09",
  startDelimiterName: "\u8D77\u59CB\u7B26\u53F7",
  startDelimiterDesc: "GhostTag\u7684\u8D77\u59CB\u7B26\u53F7\uFF08\u4F8B: %%, ((, ==\uFF09",
  endDelimiterName: "\u7ED3\u675F\u7B26\u53F7",
  endDelimiterDesc: "GhostTag\u7684\u7ED3\u675F\u7B26\u53F7\uFF08\u4F8B: %%, )), ==\uFF09",
  sectionDisplay: "\u663E\u793A",
  hoverOpacityName: "\u60AC\u505C\u65F6\u4E0D\u900F\u660E\u5EA6",
  hoverOpacityDesc: "\u9F20\u6807\u60AC\u505C\u65F6\u6587\u672C\u7684\u6D53\u5EA6 (0\u301C100%)",
  editOpacityName: "\u7F16\u8F91\u6A21\u5F0F\u4E0D\u900F\u660E\u5EA6",
  editOpacityDesc: "\u5149\u6807\u653E\u5728\u6807\u7B7E\u5185\u65F6\u7684\u6D53\u5EA6 (0\u301C100%)",
  delimOpacityName: "\u5B9A\u754C\u7B26\u4E0D\u900F\u660E\u5EA6",
  delimOpacityDesc: "\u7F16\u8F91\u6A21\u5F0F\u4E0B\u5B9A\u754C\u7B26\u7684\u6D53\u5EA6 (0\u301C100%)",
  animSpeedName: "\u52A8\u753B\u901F\u5EA6",
  animSpeedDesc: "\u6DE1\u5165/\u6DE1\u51FA\u65F6\u95F4 (\u6BEB\u79D2)",
  sectionCopy: "\u590D\u5236\u884C\u4E3A",
  autoStripName: "\u590D\u5236\u65F6\u81EA\u52A8\u53BB\u9664GhostTag",
  autoStripDesc: "\u5F00\u542F\u540E\uFF0CCtrl+C\u590D\u5236\u65F6\u4F1A\u81EA\u52A8\u53BB\u9664GhostTag",
  copyWithTags: "\u{1F47B} \u5305\u542BGhostTag\u590D\u5236",
  copyWithoutTags: "\u{1F47B} \u53BB\u9664GhostTag\u590D\u5236",
  ghostifySelection: "\u{1F47B} \u5C06\u9009\u4E2D\u5185\u5BB9Ghost\u5316",
  openScanner: "\u6253\u5F00Ghost Scanner",
  scannerTitle: "\u{1F47B} Ghost Scanner",
  scannerEmpty: "\u6B64\u7B14\u8BB0\u4E2D\u6CA1\u6709GhostTag",
  scannerNoNote: "\u8BF7\u5148\u6253\u5F00\u4E00\u4E2AMarkdown\u7B14\u8BB0",
  scannerCount: (n) => `${n} \u4E2A`
};
var ru = {
  settingsTitle: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 GhostTag",
  sectionDelimiter: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u0438",
  startDelimiterName: "\u041D\u0430\u0447\u0430\u043B\u044C\u043D\u044B\u0439 \u0440\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C",
  startDelimiterDesc: "\u0421\u0438\u043C\u0432\u043E\u043B \u043D\u0430\u0447\u0430\u043B\u0430 GhostTag (\u043D\u0430\u043F\u0440. %%, ((, ==)",
  endDelimiterName: "\u041A\u043E\u043D\u0435\u0447\u043D\u044B\u0439 \u0440\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C",
  endDelimiterDesc: "\u0421\u0438\u043C\u0432\u043E\u043B \u043A\u043E\u043D\u0446\u0430 GhostTag (\u043D\u0430\u043F\u0440. %%, )), ==)",
  sectionDisplay: "\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435",
  hoverOpacityName: "\u041F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u043E\u0441\u0442\u044C \u043F\u0440\u0438 \u043D\u0430\u0432\u0435\u0434\u0435\u043D\u0438\u0438",
  hoverOpacityDesc: "\u041F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u043E\u0441\u0442\u044C \u0442\u0435\u043A\u0441\u0442\u0430 \u043F\u0440\u0438 \u043D\u0430\u0432\u0435\u0434\u0435\u043D\u0438\u0438 \u043C\u044B\u0448\u0438 (0\u2013100%)",
  editOpacityName: "\u041F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u043E\u0441\u0442\u044C \u0432 \u0440\u0435\u0436\u0438\u043C\u0435 \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F",
  editOpacityDesc: "\u041F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u043E\u0441\u0442\u044C \u0442\u0435\u043A\u0441\u0442\u0430, \u043A\u043E\u0433\u0434\u0430 \u043A\u0443\u0440\u0441\u043E\u0440 \u0432\u043D\u0443\u0442\u0440\u0438 \u0442\u0435\u0433\u0430 (0\u2013100%)",
  delimOpacityName: "\u041F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u043E\u0441\u0442\u044C \u0440\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u0435\u0439",
  delimOpacityDesc: "\u041F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u043E\u0441\u0442\u044C \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432-\u0440\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u0435\u0439 \u0432 \u0440\u0435\u0436\u0438\u043C\u0435 \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F (0\u2013100%)",
  animSpeedName: "\u0421\u043A\u043E\u0440\u043E\u0441\u0442\u044C \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u0438",
  animSpeedDesc: "\u0414\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u043F\u043E\u044F\u0432\u043B\u0435\u043D\u0438\u044F/\u0438\u0441\u0447\u0435\u0437\u043D\u043E\u0432\u0435\u043D\u0438\u044F (\u043C\u0441)",
  sectionCopy: "\u041F\u043E\u0432\u0435\u0434\u0435\u043D\u0438\u0435 \u043F\u0440\u0438 \u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0438",
  autoStripName: "\u0410\u0432\u0442\u043E\u0443\u0434\u0430\u043B\u0435\u043D\u0438\u0435 GhostTag \u043F\u0440\u0438 \u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0438",
  autoStripDesc: "\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E, Ctrl+C \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0443\u0434\u0430\u043B\u044F\u0435\u0442 GhostTag \u0438\u0437 \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u043E\u0433\u043E \u0442\u0435\u043A\u0441\u0442\u0430",
  copyWithTags: "\u{1F47B} \u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441 GhostTag",
  copyWithoutTags: "\u{1F47B} \u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0431\u0435\u0437 GhostTag",
  ghostifySelection: "\u{1F47B} Ghostify \u0432\u044B\u0434\u0435\u043B\u0435\u043D\u0438\u0435",
  openScanner: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C Ghost Scanner",
  scannerTitle: "\u{1F47B} Ghost Scanner",
  scannerEmpty: "\u0412 \u044D\u0442\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0435 \u043D\u0435\u0442 GhostTag",
  scannerNoNote: "\u0421\u043D\u0430\u0447\u0430\u043B\u0430 \u043E\u0442\u043A\u0440\u043E\u0439\u0442\u0435 Markdown-\u0437\u0430\u043C\u0435\u0442\u043A\u0443",
  scannerCount: (n) => `\u041D\u0430\u0439\u0434\u0435\u043D\u043E: ${n}`
};
var pt = {
  settingsTitle: "Configura\xE7\xF5es do GhostTag",
  sectionDelimiter: "Delimitadores",
  startDelimiterName: "Delimitador inicial",
  startDelimiterDesc: "S\xEDmbolo que abre um GhostTag (ex: %%, ((, ==)",
  endDelimiterName: "Delimitador final",
  endDelimiterDesc: "S\xEDmbolo que fecha um GhostTag (ex: %%, )), ==)",
  sectionDisplay: "Exibi\xE7\xE3o",
  hoverOpacityName: "Opacidade ao passar o mouse",
  hoverOpacityDesc: "Opacidade do texto ao passar o mouse sobre a tag (0\u2013100%)",
  editOpacityName: "Opacidade no modo de edi\xE7\xE3o",
  editOpacityDesc: "Opacidade do texto quando o cursor est\xE1 dentro da tag (0\u2013100%)",
  delimOpacityName: "Opacidade do delimitador",
  delimOpacityDesc: "Opacidade dos s\xEDmbolos delimitadores no modo de edi\xE7\xE3o (0\u2013100%)",
  animSpeedName: "Velocidade da anima\xE7\xE3o",
  animSpeedDesc: "Dura\xE7\xE3o do fade-in/fade-out (milissegundos)",
  sectionCopy: "Comportamento de c\xF3pia",
  autoStripName: "Remover GhostTags automaticamente ao copiar",
  autoStripDesc: "Quando ativado, Ctrl+C remove automaticamente GhostTags do texto copiado",
  copyWithTags: "\u{1F47B} Copiar com GhostTags",
  copyWithoutTags: "\u{1F47B} Copiar sem GhostTags",
  ghostifySelection: "\u{1F47B} Ghostify sele\xE7\xE3o",
  openScanner: "Abrir Ghost Scanner",
  scannerTitle: "\u{1F47B} Ghost Scanner",
  scannerEmpty: "Nenhum GhostTag nesta nota",
  scannerNoNote: "Abra uma nota Markdown primeiro",
  scannerCount: (n) => `${n} encontrado(s)`
};
var fr = {
  settingsTitle: "Param\xE8tres GhostTag",
  sectionDelimiter: "D\xE9limiteurs",
  startDelimiterName: "D\xE9limiteur d'ouverture",
  startDelimiterDesc: "Symbole ouvrant un GhostTag (ex : %%, ((, ==)",
  endDelimiterName: "D\xE9limiteur de fermeture",
  endDelimiterDesc: "Symbole fermant un GhostTag (ex : %%, )), ==)",
  sectionDisplay: "Affichage",
  hoverOpacityName: "Opacit\xE9 au survol",
  hoverOpacityDesc: "Opacit\xE9 du texte au survol de la souris (0\u2013100 %)",
  editOpacityName: "Opacit\xE9 en mode \xE9dition",
  editOpacityDesc: "Opacit\xE9 du texte lorsque le curseur est dans un tag (0\u2013100 %)",
  delimOpacityName: "Opacit\xE9 des d\xE9limiteurs",
  delimOpacityDesc: "Opacit\xE9 des symboles d\xE9limiteurs en mode \xE9dition (0\u2013100 %)",
  animSpeedName: "Vitesse d'animation",
  animSpeedDesc: "Dur\xE9e du fondu (millisecondes)",
  sectionCopy: "Comportement de copie",
  autoStripName: "Supprimer les GhostTags automatiquement lors de la copie",
  autoStripDesc: "Si activ\xE9, Ctrl+C supprime automatiquement les GhostTags du texte copi\xE9",
  copyWithTags: "\u{1F47B} Copier avec les GhostTags",
  copyWithoutTags: "\u{1F47B} Copier sans les GhostTags",
  ghostifySelection: "\u{1F47B} Ghostifier la s\xE9lection",
  openScanner: "Ouvrir Ghost Scanner",
  scannerTitle: "\u{1F47B} Ghost Scanner",
  scannerEmpty: "Aucun GhostTag dans cette note",
  scannerNoNote: "Ouvrez d'abord une note Markdown",
  scannerCount: (n) => `${n} trouv\xE9(s)`
};
var de = {
  settingsTitle: "GhostTag-Einstellungen",
  sectionDelimiter: "Trennzeichen",
  startDelimiterName: "Startzeichen",
  startDelimiterDesc: "Symbol zum \xD6ffnen eines GhostTags (z. B. %%, ((, ==)",
  endDelimiterName: "Endzeichen",
  endDelimiterDesc: "Symbol zum Schlie\xDFen eines GhostTags (z. B. %%, )), ==)",
  sectionDisplay: "Anzeige",
  hoverOpacityName: "Deckkraft beim Hovern",
  hoverOpacityDesc: "Textdeckkraft bei Mauszeiger \xFCber dem Tag (0\u2013100 %)",
  editOpacityName: "Deckkraft im Bearbeitungsmodus",
  editOpacityDesc: "Textdeckkraft bei Cursor im Tag (0\u2013100 %)",
  delimOpacityName: "Trennzeichen-Deckkraft",
  delimOpacityDesc: "Deckkraft der Trennzeichen im Bearbeitungsmodus (0\u2013100 %)",
  animSpeedName: "Animationsgeschwindigkeit",
  animSpeedDesc: "Ein-/Ausblenddauer (Millisekunden)",
  sectionCopy: "Kopierverhalten",
  autoStripName: "GhostTags beim Kopieren automatisch entfernen",
  autoStripDesc: "Wenn aktiviert, entfernt Strg+C automatisch GhostTags aus dem kopierten Text",
  copyWithTags: "\u{1F47B} Mit GhostTags kopieren",
  copyWithoutTags: "\u{1F47B} Ohne GhostTags kopieren",
  ghostifySelection: "\u{1F47B} Auswahl ghostifizieren",
  openScanner: "Ghost Scanner \xF6ffnen",
  scannerTitle: "\u{1F47B} Ghost Scanner",
  scannerEmpty: "Keine GhostTags in dieser Notiz",
  scannerNoNote: "\xD6ffne zuerst eine Markdown-Notiz",
  scannerCount: (n) => `${n} gefunden`
};
var es = {
  settingsTitle: "Ajustes de GhostTag",
  sectionDelimiter: "Delimitadores",
  startDelimiterName: "Delimitador de inicio",
  startDelimiterDesc: "S\xEDmbolo que abre un GhostTag (ej: %%, ((, ==)",
  endDelimiterName: "Delimitador de cierre",
  endDelimiterDesc: "S\xEDmbolo que cierra un GhostTag (ej: %%, )), ==)",
  sectionDisplay: "Visualizaci\xF3n",
  hoverOpacityName: "Opacidad al pasar el rat\xF3n",
  hoverOpacityDesc: "Opacidad del texto al pasar el rat\xF3n sobre la etiqueta (0\u2013100%)",
  editOpacityName: "Opacidad en modo edici\xF3n",
  editOpacityDesc: "Opacidad del texto cuando el cursor est\xE1 dentro de la etiqueta (0\u2013100%)",
  delimOpacityName: "Opacidad del delimitador",
  delimOpacityDesc: "Opacidad de los s\xEDmbolos delimitadores en modo edici\xF3n (0\u2013100%)",
  animSpeedName: "Velocidad de animaci\xF3n",
  animSpeedDesc: "Duraci\xF3n del desvanecimiento (milisegundos)",
  sectionCopy: "Comportamiento de copia",
  autoStripName: "Eliminar GhostTags autom\xE1ticamente al copiar",
  autoStripDesc: "Si est\xE1 activado, Ctrl+C elimina autom\xE1ticamente los GhostTags del texto copiado",
  copyWithTags: "\u{1F47B} Copiar con GhostTags",
  copyWithoutTags: "\u{1F47B} Copiar sin GhostTags",
  ghostifySelection: "\u{1F47B} Ghostificar selecci\xF3n",
  openScanner: "Abrir Ghost Scanner",
  scannerTitle: "\u{1F47B} Ghost Scanner",
  scannerEmpty: "No hay GhostTags en esta nota",
  scannerNoNote: "Abre primero una nota Markdown",
  scannerCount: (n) => `${n} encontrado(s)`
};
var locales = {
  ja,
  en,
  zh,
  "zh-TW": zh,
  ru,
  pt,
  fr,
  de,
  es,
  "pt-BR": pt,
  "es-ES": es
};
function getLocale() {
  const lang = window.localStorage.getItem("language") || "en";
  return locales[lang] || locales[lang.split("-")[0]] || en;
}

// src/settings/settingTab.ts
var GhostTagSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    const t = getLocale();
    containerEl.empty();
    containerEl.createEl("h2", { text: t.settingsTitle });
    containerEl.createEl("h3", { text: t.sectionDelimiter });
    new import_obsidian.Setting(containerEl).setName(t.startDelimiterName).setDesc(t.startDelimiterDesc).addText(
      (text) => text.setPlaceholder("%%").setValue(this.plugin.settings.startDelimiter).onChange(async (value) => {
        if (value.trim().length === 0)
          return;
        this.plugin.settings.startDelimiter = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName(t.endDelimiterName).setDesc(t.endDelimiterDesc).addText(
      (text) => text.setPlaceholder("%%").setValue(this.plugin.settings.endDelimiter).onChange(async (value) => {
        if (value.trim().length === 0)
          return;
        this.plugin.settings.endDelimiter = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: t.sectionDisplay });
    new import_obsidian.Setting(containerEl).setName(t.hoverOpacityName).setDesc(t.hoverOpacityDesc).addSlider(
      (slider) => slider.setLimits(10, 100, 5).setValue(this.plugin.settings.hoverOpacity * 100).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.hoverOpacity = value / 100;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName(t.editOpacityName).setDesc(t.editOpacityDesc).addSlider(
      (slider) => slider.setLimits(20, 100, 5).setValue(this.plugin.settings.editOpacity * 100).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.editOpacity = value / 100;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName(t.delimOpacityName).setDesc(t.delimOpacityDesc).addSlider(
      (slider) => slider.setLimits(10, 100, 5).setValue(this.plugin.settings.editDelimOpacity * 100).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.editDelimOpacity = value / 100;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName(t.animSpeedName).setDesc(t.animSpeedDesc).addSlider(
      (slider) => slider.setLimits(0, 1e3, 50).setValue(this.plugin.settings.transitionDuration).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.transitionDuration = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: t.sectionCopy });
    new import_obsidian.Setting(containerEl).setName(t.autoStripName).setDesc(t.autoStripDesc).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoStripOnCopy).onChange(async (value) => {
        this.plugin.settings.autoStripOnCopy = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/scanner/scannerView.ts
var import_obsidian2 = require("obsidian");
var SCANNER_VIEW_TYPE = "ghost-tag-scanner";
var GhostScannerView = class extends import_obsidian2.ItemView {
  constructor(leaf) {
    super(leaf);
    this.matches = [];
  }
  getViewType() {
    return SCANNER_VIEW_TYPE;
  }
  getDisplayText() {
    return "Ghost Scanner";
  }
  getIcon() {
    return "search";
  }
  async onOpen() {
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => this.refresh())
    );
    this.registerEvent(
      this.app.workspace.on("editor-change", () => this.refresh())
    );
    this.refresh();
  }
  async onClose() {
  }
  /** Get the plugin instance to access settings */
  getPlugin() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["ghost-tag"]) != null ? _c : null;
  }
  /** Build regex from current plugin settings */
  buildScanRegex() {
    var _a, _b, _c, _d;
    const plugin = this.getPlugin();
    const start = (_b = (_a = plugin == null ? void 0 : plugin.settings) == null ? void 0 : _a.startDelimiter) != null ? _b : "%%";
    const end = (_d = (_c = plugin == null ? void 0 : plugin.settings) == null ? void 0 : _c.endDelimiter) != null ? _d : "%%";
    const esc = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return new RegExp(`${esc(start)}([\\s\\S]*?)${esc(end)}`, "g");
  }
  refresh() {
    var _a, _b, _c, _d;
    const container = this.contentEl;
    container.empty();
    const t = getLocale();
    const header = container.createDiv({ cls: "gt-scanner-header" });
    header.createEl("h4", { text: t.scannerTitle });
    const mdView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!mdView) {
      container.createEl("p", {
        text: t.scannerNoNote,
        cls: "gt-scanner-empty"
      });
      return;
    }
    const plugin = this.getPlugin();
    const delimLen = ((_b = (_a = plugin == null ? void 0 : plugin.settings) == null ? void 0 : _a.startDelimiter) != null ? _b : "%%").length;
    const editor = mdView.editor;
    const text = editor.getValue();
    const fileName = (_d = (_c = mdView.file) == null ? void 0 : _c.basename) != null ? _d : "Unknown";
    header.createEl("small", {
      text: fileName,
      cls: "gt-scanner-filename"
    });
    this.matches = [];
    const regex = this.buildScanRegex();
    let m;
    while ((m = regex.exec(text)) !== null) {
      const content = m[1].trim();
      if (content.length === 0)
        continue;
      const pos = m.index;
      const line = editor.offsetToPos(pos).line;
      this.matches.push({ content, line, offset: pos });
    }
    if (this.matches.length === 0) {
      container.createEl("p", {
        text: t.scannerEmpty,
        cls: "gt-scanner-empty"
      });
      return;
    }
    header.createEl("span", {
      text: t.scannerCount(this.matches.length),
      cls: "gt-scanner-count"
    });
    const list = container.createDiv({ cls: "gt-scanner-list" });
    for (const match of this.matches) {
      const item = list.createDiv({ cls: "gt-scanner-item" });
      item.createEl("span", {
        text: `L${match.line + 1}`,
        cls: "gt-scanner-line"
      });
      const preview = match.content.length > 60 ? match.content.substring(0, 57) + "\u2026" : match.content;
      item.createEl("span", {
        text: preview,
        cls: "gt-scanner-text"
      });
      item.addEventListener("click", () => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
        if (!view)
          return;
        const pos = view.editor.offsetToPos(match.offset + delimLen);
        view.editor.setCursor(pos);
        view.editor.focus();
      });
    }
  }
};

// src/settings/types.ts
var DEFAULT_SETTINGS = {
  hoverOpacity: 0.55,
  editOpacity: 0.75,
  editDelimOpacity: 0.35,
  transitionDuration: 250,
  startDelimiter: "%%",
  endDelimiter: "%%",
  autoStripOnCopy: true
};

// main.ts
var import_state3 = require("@codemirror/state");
var GhostTagPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.ghostConfigCompartment = new import_state3.Compartment();
    this.copyConfigCompartment = new import_state3.Compartment();
  }
  async onload() {
    console.log("GhostTag v1.6: Loading...");
    await this.loadSettings();
    this.registerEditorExtension([
      this.ghostConfigCompartment.of(
        ghostConfigFacet.of(this.buildEditorConfig())
      ),
      this.copyConfigCompartment.of(
        ghostCopyConfigFacet.of(this.buildCopyConfig())
      ),
      ghostTagPlugin,
      ghostCopyHandler
    ]);
    this.addSettingTab(new GhostTagSettingTab(this.app, this));
    this.registerView(
      SCANNER_VIEW_TYPE,
      (leaf) => new GhostScannerView(leaf)
    );
    const t = getLocale();
    this.addRibbonIcon("search", "Ghost Scanner", () => {
      this.activateScanner();
    });
    this.addCommand({
      id: "open-ghost-scanner",
      name: t.openScanner,
      callback: () => this.activateScanner()
    });
    this.addCommand({
      id: "copy-with-ghost-tags",
      name: t.copyWithTags,
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        if (selection.length > 0) {
          navigator.clipboard.writeText(selection);
        }
      }
    });
    this.addCommand({
      id: "copy-without-ghost-tags",
      name: t.copyWithoutTags,
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        if (selection.length > 0) {
          const stripped = stripGhostTags(
            selection,
            this.settings.startDelimiter,
            this.settings.endDelimiter
          );
          navigator.clipboard.writeText(stripped);
        }
      }
    });
    this.addCommand({
      id: "ghostify-selection",
      name: t.ghostifySelection,
      editorCallback: (editor) => this.ghostifySelection(editor),
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "g" }]
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor) => {
        const selection = editor.getSelection();
        menu.addSeparator();
        menu.addItem((item) => {
          item.setTitle(t.ghostifySelection).setIcon("quote-glyph").onClick(() => this.ghostifySelection(editor));
        });
        if (selection.length > 0) {
          menu.addItem((item) => {
            item.setTitle(t.copyWithTags).setIcon("copy").onClick(() => {
              navigator.clipboard.writeText(selection);
            });
          });
          menu.addItem((item) => {
            item.setTitle(t.copyWithoutTags).setIcon("scissors").onClick(() => {
              const stripped = stripGhostTags(
                selection,
                this.settings.startDelimiter,
                this.settings.endDelimiter
              );
              navigator.clipboard.writeText(stripped);
            });
          });
        }
      })
    );
    this.applyCssVariables();
  }
  onunload() {
    console.log("GhostTag v1.6: Unloading...");
    const props = [
      "--gt-hover-opacity",
      "--gt-edit-opacity",
      "--gt-edit-delim-opacity",
      "--gt-transition"
    ];
    props.forEach((p) => document.body.style.removeProperty(p));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.applyCssVariables();
    this.reconfigureEditorExtension();
  }
  buildEditorConfig() {
    return {
      startDelimiter: this.settings.startDelimiter,
      endDelimiter: this.settings.endDelimiter
    };
  }
  buildCopyConfig() {
    return {
      autoStrip: this.settings.autoStripOnCopy,
      startDelimiter: this.settings.startDelimiter,
      endDelimiter: this.settings.endDelimiter
    };
  }
  reconfigureEditorExtension() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a, _b;
      const editor = (_b = (_a = leaf.view) == null ? void 0 : _a.editor) == null ? void 0 : _b.cm;
      if (editor == null ? void 0 : editor.dispatch) {
        editor.dispatch({
          effects: [
            this.ghostConfigCompartment.reconfigure(
              ghostConfigFacet.of(this.buildEditorConfig())
            ),
            this.copyConfigCompartment.reconfigure(
              ghostCopyConfigFacet.of(this.buildCopyConfig())
            )
          ]
        });
      }
    });
  }
  /** Apply settings to CSS custom properties (gt- namespaced) */
  applyCssVariables() {
    const s = this.settings;
    document.body.style.setProperty("--gt-hover-opacity", String(s.hoverOpacity));
    document.body.style.setProperty("--gt-edit-opacity", String(s.editOpacity));
    document.body.style.setProperty("--gt-edit-delim-opacity", String(s.editDelimOpacity));
    document.body.style.setProperty("--gt-transition", `${s.transitionDuration}ms`);
  }
  async activateScanner() {
    const existing = this.app.workspace.getLeavesOfType(SCANNER_VIEW_TYPE);
    if (existing.length > 0) {
      existing.forEach((leaf2) => leaf2.detach());
      return;
    }
    const leaf = this.app.workspace.getRightLeaf(false);
    if (leaf) {
      await leaf.setViewState({
        type: SCANNER_VIEW_TYPE,
        active: true
      });
      this.app.workspace.revealLeaf(leaf);
    }
  }
  /** Ghostify / Unghostify toggle for selection(s) */
  ghostifySelection(editor) {
    const sd = this.settings.startDelimiter;
    const ed = this.settings.endDelimiter;
    const selections = editor.listSelections();
    const sortedSelections = [...selections].sort((a, b) => {
      const aLine = Math.min(a.anchor.line, a.head.line);
      const bLine = Math.min(b.anchor.line, b.head.line);
      if (aLine !== bLine)
        return bLine - aLine;
      const aCh = Math.min(a.anchor.ch, a.head.ch);
      const bCh = Math.min(b.anchor.ch, b.head.ch);
      return bCh - aCh;
    });
    for (const sel of sortedSelections) {
      const from = {
        line: Math.min(sel.anchor.line, sel.head.line),
        ch: sel.anchor.line === sel.head.line ? Math.min(sel.anchor.ch, sel.head.ch) : sel.anchor.line < sel.head.line ? sel.anchor.ch : sel.head.ch
      };
      const to = {
        line: Math.max(sel.anchor.line, sel.head.line),
        ch: sel.anchor.line === sel.head.line ? Math.max(sel.anchor.ch, sel.head.ch) : sel.anchor.line > sel.head.line ? sel.anchor.ch : sel.head.ch
      };
      const text = editor.getRange(from, to);
      if (text.length === 0) {
        editor.replaceRange(sd + ed, from);
        editor.setCursor({ line: from.line, ch: from.ch + sd.length });
      } else if (text.startsWith(sd) && text.endsWith(ed) && text.length >= sd.length + ed.length) {
        const inner = text.slice(sd.length, text.length - ed.length);
        editor.replaceRange(inner, from, to);
        editor.setSelection(from, { line: from.line + inner.split("\n").length - 1, ch: inner.includes("\n") ? inner.split("\n").pop().length : from.ch + inner.length });
      } else {
        const wrapped = sd + text + ed;
        editor.replaceRange(wrapped, from, to);
        const newEndLine = from.line + wrapped.split("\n").length - 1;
        const newEndCh = wrapped.includes("\n") ? wrapped.split("\n").pop().length : from.ch + wrapped.length;
        editor.setSelection(from, { line: newEndLine, ch: newEndCh });
      }
    }
  }
};
